package com.mancode.financetracker

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import androidx.navigation.fragment.NavHostFragment
import co.csadev.kellocharts.gesture.ContainerScrollType
import co.csadev.kellocharts.model.*
import com.mancode.financetracker.database.entity.NetValue
import com.mancode.financetracker.database.entity.TransactionEntity
import com.mancode.financetracker.ui.hideKeyboard
import com.mancode.financetracker.ui.setFormattedMoney
import com.mancode.financetracker.viewmodel.ReportViewModel
import com.mancode.financetracker.viewmodel.ReportViewModel.Companion.MONTH_NEXT
import com.mancode.financetracker.viewmodel.ReportViewModel.Companion.MONTH_PREVIOUS
import com.mancode.financetracker.viewmodel.ReportViewModel.Companion.MONTH_THIS
import kotlinx.android.synthetic.main.fragment_report_monthly.*
import org.threeten.bp.LocalDate

class ReportFragment : Fragment() {

    private val viewModel: ReportViewModel by viewModels()

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        viewModel.netValues.observe(viewLifecycleOwner, Observer { updateChartData(it) })
        resetObservers()
        return inflater.inflate(R.layout.fragment_report_monthly, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        toolbar.setNavigationOnClickListener { dismiss() }
        toolbar.setNavigationIcon(R.drawable.ic_arrow_back_24dp)

        netValueChart.setContainerScrollEnabled(true, ContainerScrollType.HORIZONTAL)
        netValueChart.isZoomEnabled = false

        val values = arrayListOf<PointValue>()
        val line = Line(values, isCubic = true, hasLabels = false, hasPoints = false, pointRadius = 2)
        val data = LineChartData(arrayListOf(line))
        data.axisXBottom = getAxisXFormatted(isAutoGenerated = true)
        netValueChart.lineChartData = data

        btnPrev.setOnClickListener {
            initReport(MONTH_PREVIOUS)
        }
        btnNext.setOnClickListener {
            initReport(MONTH_NEXT)
        }
        btnRange.setOnClickListener {
            initReport(MONTH_THIS)
        }
    }

    private fun updateChartData(netValues: List<NetValue>) {
        if (netValues.isEmpty()) return
        val newValues = netValues
                .map { PointValue(it.date.toEpochDay().toFloat(), it.value.toFloat()) }
                .toMutableList()
        val datesSorted = netValues.map { it.date }.sorted()
        val valuesSorted = netValues.map { it.value.toFloat() }.sorted()
        val dateMin = datesSorted[0]
        val dateMax = datesSorted[datesSorted.size - 1]
        val valueMin = valuesSorted[0]
        val valueMax = valuesSorted[valuesSorted.size - 1]
        val deltaY = valueMax - valueMin
        val axisXValues = datesSorted
                .filter { it.dayOfMonth == 1 }
                .map { date -> AxisValue(date.toEpochDay().toFloat(), date.toString().toCharArray()) }
                .toMutableList()
        val data = netValueChart.lineChartData
        data.axisXBottom = getAxisXFormatted(axisXValues)
        val color = ContextCompat.getColor(context!!, R.color.colorSecondaryVariant)
        data.lines[0] = Line(newValues, color = color, isCubic = true, hasLabels = false,
                hasLabelsOnlyForSelected = true, isFilled = true, pointRadius = 2)
        netValueChart.maximumViewport = Viewport(
                left = dateMin.toEpochDay().toFloat(),
                right = dateMax.toEpochDay().toFloat(),
                top = valueMax + 0.05f * deltaY,
                bottom = valueMin - 0.05f * deltaY)
        val currentViewport = netValueChart.maximumViewport.copy().apply {
            left = right - 60f
        }
        netValueChart.currentViewport = currentViewport
    }

    private fun getAxisXFormatted(axisXValues: MutableList<AxisValue> = ArrayList(),
                                  isAutoGenerated: Boolean = false) =
            Axis(axisXValues, hasLines = true, maxLabelChars = 10, isAutoGenerated = isAutoGenerated)

    private fun initReport(whichMonth: Int) {
        viewModel.initReport(whichMonth)
        resetObservers()
    }

    private fun resetObservers() {
        val transactions: LiveData<List<TransactionEntity>> = viewModel.getTransactions()
        transactions.removeObservers(this)
        transactions.observe(viewLifecycleOwner, Observer {
            viewModel.report.setTransactions(it)
            if (viewModel.report.dataPresent())
                updateViews()
        })
        val netValueBeforeFrom: LiveData<NetValue> = viewModel.getNetValueBeforeFrom()
        netValueBeforeFrom.removeObservers(this)
        netValueBeforeFrom.observe(viewLifecycleOwner, Observer {
            viewModel.report.netValue1 = it
            if (viewModel.report.dataPresent())
                updateViews()
        })
        val netValueBeforeTo: LiveData<NetValue> = viewModel.getNetValueBeforeTo() // TODO algorithm for choosing netvalues
        netValueBeforeTo.removeObservers(this)
        netValueBeforeTo.observe(viewLifecycleOwner, Observer {
            viewModel.report.netValue2 = it
            if (viewModel.report.dataPresent())
                updateViews()
        })
    }

    private fun updateViews() {
        val reportRange = viewModel.report.from.toString() + " - " + viewModel.report.to.toString()
        btnRange.text = reportRange
        tvIncome.setFormattedMoney(viewModel.report.income)
        tvRegisteredOutcome.setFormattedMoney(viewModel.report.registeredOutcome)
        tvUnregisteredOutcome.setFormattedMoney(viewModel.report.unregisteredOutcome)
        tvBalance.setFormattedMoney(viewModel.report.balance)
        btnNext.isEnabled = !viewModel.report.to.isAfter(LocalDate.now())
        updateNetValueViews()
        adjustChartViewport()
    }

    private fun updateNetValueViews() {
        val value1Set = viewModel.report.netValue1 != null
        val value2Set = viewModel.report.netValue2 != null
        if (value1Set) {
            tvNetValueDate1.text = viewModel.report.netValue1.date.toString()
            tvNetValue1.setFormattedMoney(viewModel.report.netValue1.value)
            btnPrev.isEnabled = true
        } else {
            tvNetValueDate1.text = "n/a"
            tvNetValue1.text = "n/a"
            btnPrev.isEnabled = false
        }
        if (value2Set) {
            tvNetValueDate2.text = viewModel.report.netValue2.date.toString()
            tvNetValue2.setFormattedMoney(viewModel.report.netValue2.value)
        } else {
            tvNetValueDate2.text = "n/a"
            tvNetValue2.text = "n/a"
        }
        if (value1Set && value2Set) {
            tvCalcOutcome.setFormattedMoney(viewModel.report.calculatedOutcome)
        } else {
            tvCalcOutcome.text = "n/a"
        }
    }

    private fun adjustChartViewport() {
        val mv = netValueChart.maximumViewport
        if (mv.left > mv.right) return
        val x = ((viewModel.report.to.toEpochDay().toFloat() + viewModel.report.from.toEpochDay().toFloat()) / 2)
                .coerceIn(mv.left, mv.right - 0.1f) // end of range needs to be open for scroll to work
        val y = (mv.top + mv.bottom) / 2
        netValueChart.moveToWithAnimation(x, y)
    }

    private fun dismiss() {
        this.hideKeyboard()
        NavHostFragment.findNavController(this).navigateUp()
    }
}