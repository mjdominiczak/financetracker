package com.mancode.financetracker

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProviders
import co.csadev.kellocharts.gesture.ContainerScrollType
import co.csadev.kellocharts.model.*
import com.mancode.financetracker.database.entity.NetValue
import com.mancode.financetracker.viewmodel.ReportViewModel
import kotlinx.android.synthetic.main.fragment_report.*
import org.threeten.bp.LocalDate

class ReportFragment : Fragment() {

    private val viewModel: ReportViewModel by lazy {
        ViewModelProviders.of(this).get(ReportViewModel::class.java)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewModel.netValues.observe(viewLifecycleOwner, Observer { netValues -> updateChartData(netValues) })
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_report, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        netValueChart.setContainerScrollEnabled(true, ContainerScrollType.HORIZONTAL)

        val values = arrayListOf(
                PointValue(LocalDate.now().minusMonths(6).toEpochDay().toInt(), 0),
                PointValue(LocalDate.now().toEpochDay().toInt(), 0))
        val line = Line(values, isCubic = true, hasLabels = false, hasPoints = false, pointRadius = 2)
        val data = LineChartData(arrayListOf(line))
        data.axisXBottom = getAxisXFormatted(isAutoGenerated = true)
        data.axisYRight = getAxisYFormatted()

        netValueChart.lineChartData = data
    }

    private fun updateChartData(netValues: List<NetValue>) {
        val newValues = netValues
                .map { PointValue(it.date.toEpochDay().toFloat(), it.value.toFloat()) }
                .toMutableList()
        val datesSorted = netValues.map { it.date }.sorted()
        val valuesSorted = netValues.map { it.value.toFloat() }.sorted()
        val dateMin = datesSorted[0]
        val dateMax = datesSorted[datesSorted.size - 1]
        val valueMax = valuesSorted[valuesSorted.size - 1]
        val valueMin = valuesSorted[0]
        val deltaY = valueMax - valueMin
        val axisXValues = datesSorted
                .filter { it.dayOfMonth == 1 }
                .map { date -> AxisValue(date.toEpochDay().toFloat(), date.toString().toCharArray()) }
                .toMutableList()
        val data = netValueChart.lineChartData
        data.axisXBottom = getAxisXFormatted(axisXValues)
        data.axisYRight = getAxisYFormatted()
        val color = ContextCompat.getColor(context!!, R.color.colorSecondaryVariant)
        data.lines[0] = Line(newValues, color = color, isCubic = true, hasLabels = false,
                hasLabelsOnlyForSelected = true, isFilled = true, pointRadius = 2)
        var v = Viewport(
                left = dateMin.toEpochDay().toFloat(),
                right = dateMax.toEpochDay().toFloat(),
                top = valueMax + 0.05f * deltaY,
                bottom = valueMin - 0.05f * deltaY)
        netValueChart.maximumViewport = v
        v = netValueChart.maximumViewport.copy()
        v.left = netValueChart.maximumViewport.right - 180f
        netValueChart.setCurrentViewportWithAnimation(v)
    }

    private fun getAxisXFormatted(axisXValues: MutableList<AxisValue> = ArrayList(),
                                  isAutoGenerated: Boolean = false) =
            Axis(axisXValues, hasLines = true, maxLabelChars = 10, isAutoGenerated = isAutoGenerated)

    private fun getAxisYFormatted() = Axis(maxLabelChars = 6, isInside = true)

}