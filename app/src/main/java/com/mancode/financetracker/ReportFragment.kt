package com.mancode.financetracker

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.lifecycle.LiveData
import androidx.navigation.fragment.NavHostFragment
import co.csadev.kellocharts.gesture.ContainerScrollType
import co.csadev.kellocharts.model.*
import com.mancode.financetracker.database.entity.NetValue
import com.mancode.financetracker.database.entity.TransactionEntity
import com.mancode.financetracker.databinding.FragmentReportMonthlyBinding
import com.mancode.financetracker.ui.hideKeyboard
import com.mancode.financetracker.ui.setFormattedMoney
import com.mancode.financetracker.viewmodel.ReportViewModel
import com.mancode.financetracker.viewmodel.ReportViewModel.Companion.MONTH_NEXT
import com.mancode.financetracker.viewmodel.ReportViewModel.Companion.MONTH_PREVIOUS
import com.mancode.financetracker.viewmodel.ReportViewModel.Companion.MONTH_THIS
import org.threeten.bp.LocalDate
import kotlin.math.max

class ReportFragment : Fragment(R.layout.fragment_report_monthly) {

    private var _binding: FragmentReportMonthlyBinding? = null
    private val binding get() = _binding!!
    private val viewModel: ReportViewModel by viewModels()

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View {
        _binding = FragmentReportMonthlyBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewModel.netValues.observe(viewLifecycleOwner, { netValues ->
            if (netValues.isEmpty() || netValues.size == 1) {
                disableButtons()
                binding.emptyChartInfo.visibility = View.VISIBLE
            } else {
                enableButtons()
                binding.emptyChartInfo.visibility = View.GONE
                updateChartData(netValues)
            }
        })
        resetObservers()
        binding.toolbar.setNavigationOnClickListener { dismiss() }
        binding.toolbar.setNavigationIcon(R.drawable.ic_arrow_back_24dp)

        binding.netValueChart.setContainerScrollEnabled(true, ContainerScrollType.HORIZONTAL)
        binding.netValueChart.isZoomEnabled = false

        val values = arrayListOf<PointValue>()
        val line = Line(values, isCubic = true, hasLabels = false, hasPoints = false, pointRadius = 2)
        val data = LineChartData(arrayListOf(line))
        data.axisXBottom = getAxisXFormatted(isAutoGenerated = true)
        binding.netValueChart.lineChartData = data

        binding.btnPrev.setOnClickListener {
            initReport(MONTH_PREVIOUS)
        }
        binding.btnNext.setOnClickListener {
            initReport(MONTH_NEXT)
        }
        binding.btnRange.setOnClickListener {
            initReport(MONTH_THIS)
        }
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }

    private fun updateChartData(netValues: List<NetValue>) {
        if (netValues.isEmpty()) return
        val newValues = netValues
                .sortedBy { it.date }
                .map { PointValue(it.date.toEpochDay().toFloat(), it.value.toFloat()) }
                .toMutableList()
        val datesSorted = netValues.map { it.date }.sorted()
        val valuesSorted = netValues.map { it.value.toFloat() }.sorted()
        val dateMin = datesSorted[0]
        val dateMax = datesSorted[datesSorted.size - 1]
        val valueMin = valuesSorted[0]
        val valueMax = valuesSorted[valuesSorted.size - 1]
        val deltaY = valueMax - valueMin
        val axisXValues = datesSorted
                .filter { it.dayOfMonth == 1 }
                .map { date -> AxisValue(date.toEpochDay().toFloat(), date.toString().toCharArray()) }
                .toMutableList()
        val data = binding.netValueChart.lineChartData
        data.axisXBottom = getAxisXFormatted(axisXValues)
        val color = ContextCompat.getColor(requireContext(), R.color.colorSecondaryVariant)
        data.lines[0] = Line(newValues, color = color, isCubic = true, hasLabels = false,
                hasLabelsOnlyForSelected = true, isFilled = true, pointRadius = 2)
        binding.netValueChart.maximumViewport = Viewport(
                left = dateMin.toEpochDay().toFloat(),
                right = dateMax.toEpochDay().toFloat(),
                top = valueMax + max(0.05f * deltaY, 0.01f),
                bottom = valueMin - max(0.05f * deltaY, 0.01f))
        val currentViewport = binding.netValueChart.maximumViewport.copy().apply {
            left = right - 60f
        }
        binding.netValueChart.currentViewport = currentViewport
    }

    private fun getAxisXFormatted(axisXValues: MutableList<AxisValue> = ArrayList(),
                                  isAutoGenerated: Boolean = false) =
            Axis(axisXValues, hasLines = true, maxLabelChars = 10, isAutoGenerated = isAutoGenerated)

    private fun initReport(whichMonth: Int) {
        viewModel.initReport(whichMonth)
        resetObservers()
    }

    private fun resetObservers() {
        val transactions: LiveData<List<TransactionEntity>> = viewModel.getTransactions()
        transactions.removeObservers(this)
        transactions.observe(viewLifecycleOwner, {
            viewModel.report.setTransactions(it)
            if (viewModel.report.dataPresent())
                updateViews()
        })
        val netValueBeforeFrom: LiveData<NetValue> = viewModel.getNetValueClosestToFrom()
        netValueBeforeFrom.removeObservers(this)
        netValueBeforeFrom.observe(viewLifecycleOwner, {
            viewModel.report.netValue1 = it
            if (viewModel.report.dataPresent())
                updateViews()
        })
        val netValueBeforeTo: LiveData<NetValue> = viewModel.getNetValueClosestToTo() // TODO algorithm for choosing netvalues
        netValueBeforeTo.removeObservers(this)
        netValueBeforeTo.observe(viewLifecycleOwner, {
            viewModel.report.netValue2 = it
            if (viewModel.report.dataPresent())
                updateViews()
        })
    }

    private fun updateViews() {
        val reportRange = viewModel.report.from.toString() + " - " + viewModel.report.to.toString()
        with(binding) {
            btnRange.text = reportRange
            tvIncome.setFormattedMoney(viewModel.report.income)
            tvRegisteredOutcome.setFormattedMoney(viewModel.report.registeredOutcome)
            tvUnregisteredOutcome.setFormattedMoney(viewModel.report.unregisteredOutcome)
            tvBalance.setFormattedMoney(viewModel.report.balance)
            btnNext.isEnabled = !viewModel.report.to.isAfter(LocalDate.now())
        }
        updateNetValueViews()
        adjustChartViewport()
    }

    private fun updateNetValueViews() {
        val value1Set = viewModel.report.netValue1 != null // TODO always true because querying for closest netvalue?
        val value2Set = viewModel.report.netValue2 != null
        if (value1Set) {
            binding.tvNetValueDate1.text = viewModel.report.netValue1.date.toString()
            binding.tvNetValue1.setFormattedMoney(viewModel.report.netValue1.value)
            binding.btnPrev.isEnabled = viewModel.report.netValue1.date.isEqual(viewModel.report.from)
        } else {
            binding.tvNetValueDate1.text = "n/a"
            binding.tvNetValue1.text = "n/a"
        }
        if (value2Set) {
            binding.tvNetValueDate2.text = viewModel.report.netValue2.date.toString()
            binding.tvNetValue2.setFormattedMoney(viewModel.report.netValue2.value)
        } else {
            binding.tvNetValueDate2.text = "n/a"
            binding.tvNetValue2.text = "n/a"
        }
        if (value1Set && value2Set) {
            binding.tvCalcOutcome.setFormattedMoney(viewModel.report.calculatedOutcome)
        } else {
            binding.tvCalcOutcome.text = "n/a"
        }
    }

    private fun adjustChartViewport() {
        val mv = binding.netValueChart.maximumViewport
        if (mv.left > mv.right) return
        val x = ((viewModel.report.to.toEpochDay().toFloat() + viewModel.report.from.toEpochDay().toFloat()) / 2)
                .coerceIn(mv.left, mv.right - 0.1f) // end of range needs to be open for scroll to work
        val y = (mv.top + mv.bottom) / 2
        binding.netValueChart.moveToWithAnimation(x, y)
    }

    private fun enableButtons() {
        with(binding) {
            btnNext.isEnabled = true
            btnPrev.isEnabled = true
            btnRange.isEnabled = true
        }
    }

    private fun disableButtons() {
        with(binding) {
            btnNext.isEnabled = false
            btnPrev.isEnabled = false
            btnRange.isEnabled = false
        }
    }

    private fun dismiss() {
        this.hideKeyboard()
        NavHostFragment.findNavController(this).navigateUp()
    }
}